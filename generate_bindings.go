package main

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/crypto"
)

func main() {
	// Create contracts directory if it doesn't exist
	if err := os.MkdirAll("contracts", 0755); err != nil {
		panic(err)
	}

	// ABI files to process
	abiFiles := []struct {
		name     string
		fileName string
		typeName string
	}{
		{"ERC20", "abis/ERC20.json", "ERC20"},
		{"EndpointV2", "abis/EndpointV2.json", "EndpointV2"},
		{"EndpointV2View", "abis/EndpointV2View.json", "EndpointV2View"},
		{"IOFT", "abis/ioft.json", "IOFT"},
	}

	for _, af := range abiFiles {
		fmt.Printf("Generating %s bindings...\n", af.name)

		// Read ABI file
		abiBytes, err := os.ReadFile(af.fileName)
		if err != nil {
			panic(fmt.Sprintf("failed to read %s: %v", af.fileName, err))
		}

		// Parse ABI
		contractABI, err := abi.JSON(bytes.NewReader(abiBytes))
		if err != nil {
			panic(fmt.Sprintf("failed to parse %s ABI: %v", af.name, err))
		}

		// Generate Go bindings
		outputFile := filepath.Join("contracts", strings.ToLower(af.name)+"_bindings.go")
		f, err := os.Create(outputFile)
		if err != nil {
			panic(fmt.Sprintf("failed to create %s: %v", outputFile, err))
		}
		defer f.Close()

		// Generate the binding code
		if err := bind.GenBindings(&bind.BindConfig{
			ABI:       contractABI,
			Lang:      "go",
			Package:   "contracts",
			Type:      af.typeName,
			Filename:  outputFile,
			GoHeader:  "// Code generated by go generate; DO NOT EDIT.",
			Aliases:   nil,
			Signer:    crypto.Keccak256Hash([]byte("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)").Bytes()),
		}, f); err != nil {
			panic(fmt.Sprintf("failed to generate %s bindings: %v", af.name, err))
		}

		fmt.Printf("Generated %s bindings to %s\n", af.name, outputFile)
	}

	fmt.Println("All bindings generated successfully!")
}
